#!/usr/bin/env bun

import { $ } from "bun";
import { existsSync } from "fs";
import { resolve, dirname, basename } from "path";
import * as readline from "readline";

const SCRIPT_DIR = dirname(Bun.main);
const REPO_DIR = dirname(SCRIPT_DIR);
const IMAGE_NAME = "clorb";

interface GitStatus {
  isRepo: boolean;
  branch?: string;
  hasUncommittedChanges?: boolean;
  hasUntrackedFiles?: boolean;
  unpushedCommits?: number;
  issues: string[];
}

async function checkGitStatus(path: string): Promise<GitStatus> {
  const status: GitStatus = { isRepo: false, issues: [] };

  // Check if it's a git repo
  try {
    await $`git -C ${path} rev-parse --git-dir`.quiet();
    status.isRepo = true;
  } catch {
    return status;
  }

  // Get current branch
  try {
    const result = await $`git -C ${path} branch --show-current`.quiet();
    status.branch = result.text().trim();
    if (status.branch !== "main") {
      status.issues.push(`On branch '${status.branch}' (expected 'main')`);
    }
  } catch {
    status.issues.push("Could not determine current branch");
  }

  // Check for uncommitted changes (staged or unstaged)
  try {
    const result = await $`git -C ${path} status --porcelain`.quiet();
    const lines = result.text().trim().split("\n").filter(Boolean);
    const tracked = lines.filter((l) => !l.startsWith("??"));
    const untracked = lines.filter((l) => l.startsWith("??"));

    if (tracked.length > 0) {
      status.hasUncommittedChanges = true;
      status.issues.push(`${tracked.length} uncommitted change(s)`);
    }
    if (untracked.length > 0) {
      status.hasUntrackedFiles = true;
      status.issues.push(`${untracked.length} untracked file(s)`);
    }
  } catch {
    status.issues.push("Could not check for uncommitted changes");
  }

  // Check for unpushed commits
  try {
    const result =
      await $`git -C ${path} rev-list --count @{upstream}..HEAD`.quiet();
    const count = parseInt(result.text().trim(), 10);
    if (count > 0) {
      status.unpushedCommits = count;
      status.issues.push(`${count} unpushed commit(s)`);
    }
  } catch {
    // No upstream or other error - skip this check
  }

  return status;
}

async function promptContinue(issues: string[]): Promise<boolean> {
  console.log("\nGit status check found issues:");
  for (const issue of issues) {
    console.log(`  - ${issue}`);
  }
  console.log();

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question("Continue anyway? [y/N] ", (answer) => {
      rl.close();
      resolve(answer.toLowerCase() === "y");
    });
  });
}

function usage() {
  console.log(`clorb - Run Claude Code in an isolated Docker container

Usage: clorb [options] <path>

Arguments:
  <path>        Directory to mount and work in

Options:
  --gh          Enable GitHub CLI authentication (requires 'gh auth login')
  --rebuild     Rebuild the Docker image and exit
  -h, --help    Show this help message

Examples:
  clorb .                  Run Claude in the current directory
  clorb ~/projects/myapp   Run Claude in a specific project
  clorb --gh .             Run with GitHub CLI access for PRs and issues
  clorb --rebuild          Rebuild the container image`);
}

async function dockerExists(): Promise<boolean> {
  try {
    await $`docker --version`.quiet();
    return true;
  } catch {
    return false;
  }
}

async function imageExists(): Promise<boolean> {
  try {
    await $`docker image inspect ${IMAGE_NAME}`.quiet();
    return true;
  } catch {
    return false;
  }
}

async function buildImage() {
  console.log("Building clorb image...");
  await $`docker build -t ${IMAGE_NAME} ${REPO_DIR}`;
}

async function getGhToken(): Promise<string | null> {
  try {
    const result = await $`gh auth token`.quiet();
    return result.text().trim() || null;
  } catch {
    return null;
  }
}

async function main() {
  const args = process.argv.slice(2);

  // Handle help
  if (args.includes("-h") || args.includes("--help")) {
    usage();
    process.exit(0);
  }

  // Check docker
  if (!(await dockerExists())) {
    console.error("Error: Docker is not installed.");
    console.error("Install OrbStack from: https://orbstack.dev");
    process.exit(1);
  }

  // Handle --rebuild
  if (args.includes("--rebuild")) {
    await buildImage();
    process.exit(0);
  }

  // Parse flags
  let mountGh = false;
  const remaining: string[] = [];

  for (const arg of args) {
    if (arg === "--gh") {
      mountGh = true;
    } else if (!arg.startsWith("--")) {
      remaining.push(arg);
    } else {
      console.error(`Error: Unknown option '${arg}'`);
      console.error();
      usage();
      process.exit(1);
    }
  }

  // Require path
  if (remaining.length === 0) {
    usage();
    process.exit(1);
  }

  const targetPath = resolve(remaining[0]);
  if (!existsSync(targetPath)) {
    console.error(`Error: Path does not exist: ${targetPath}`);
    process.exit(1);
  }

  const dirName = basename(targetPath);

  // Check git status
  const gitStatus = await checkGitStatus(targetPath);
  if (gitStatus.isRepo && gitStatus.issues.length > 0) {
    const shouldContinue = await promptContinue(gitStatus.issues);
    if (!shouldContinue) {
      process.exit(0);
    }
  }

  // Build image if needed
  if (!(await imageExists())) {
    console.log("Building clorb image (first run only)...");
    await buildImage();
  }

  // Get gh token if requested
  let ghToken: string | null = null;
  if (mountGh) {
    ghToken = await getGhToken();
    if (!ghToken) {
      console.error("Error: gh is not authenticated. Run 'gh auth login' first.");
      process.exit(1);
    }
  }

  // Spawn the shell script for TTY handling
  const runScript = resolve(SCRIPT_DIR, "run.sh");

  // Filter out undefined env values
  const baseEnv: Record<string, string> = {};
  for (const [k, v] of Object.entries(process.env)) {
    if (v !== undefined) baseEnv[k] = v;
  }

  const env: Record<string, string> = {
    ...baseEnv,
    CLORB_TARGET_PATH: targetPath,
    CLORB_DIR_NAME: dirName,
    CLORB_IMAGE_NAME: IMAGE_NAME,
  };

  if (ghToken) {
    env.GH_TOKEN = ghToken;
  }

  const proc = Bun.spawn(["bash", runScript], {
    stdio: ["inherit", "inherit", "inherit"],
    env,
  });

  const exitCode = await proc.exited;
  process.exit(exitCode);
}

main();
